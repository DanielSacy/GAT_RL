import copy
import torch
from scipy.stats import ttest_rel
from RL.Pairwise_cost import pairwise_cost


# Define the device
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

def rollout(model, dataset, n_nodes, T):
    model.eval()  # Set the model to evaluation mode

    def eval_model_bat(batch):
        with torch.no_grad():  # No gradients during evaluation
            # Simulate the model on the batchch of instances
            tour, _ = model(batch, n_nodes * 2, greedy=True, T=T)
            # Compute the cost of the tour using the reward function
            cost = pairwise_cost(tour.detach(), batch)
        return cost

    # Concatenate all the results across the dataset
    total_cost = torch.cat([eval_model_bat(batch.to(device)) for batch in dataset], dim=0)
    return total_cost

class RolloutBaseline():
    """
    A baseline class that uses rollout to generate predictions.

    Attributes:
        model (nn.Module): The model to use for generating rollouts.
        dataset (list[torch.Tensor]): The dataset to generate rollouts from.
        n_nodes (int, optional): The number of nodes in the VRP/TSP. Defaults to 20.
        epoch (int, optional): The current epoch. Defaults to 0.
        T (float, optional): The temperature for the softmax. Defaults to 1.0.
    """

    def __init__(self, model, dataset, n_nodes=20, epoch=0, T=1.0):
        super(RolloutBaseline, self).__init__()
        self.n_nodes = n_nodes  # Number of nodes in the VRP/TSP
        self.dataset = dataset  # Dataset to generate rollouts
        self.T = T  # Temperature for the softmax
        """
        Initializes the baseline with the current model.

        Args:
            model (nn.Module): The model to use for generating rollouts.
            epoch (int, optional): The current epoch. Defaults to 0.
        """
        self._update_model(model, epoch)  # Initialize the baseline with the current model

    def _update_model(self, model, epoch):
        """
        Deepcopy the model and compute baseline values.

        Args:
            model (torch.nn.Module): The model to be updated.
            epoch (int): The current epoch number.

        Returns:
            None
        """
        # Create a deep copy of the input model and move it to the desired device
        self.model = copy.deepcopy(model).to(device)  
        # Run rollouts on the copied model, compute baseline values and mean cost
        self.bl_vals = rollout(self.model, self.dataset, self.n_nodes, self.T)#.cpu().numpy()  # Compute the baseline values
        self.mean = self.bl_vals.mean()  # Calculate the mean of the baseline values
        self.epoch = epoch

    def eval(self, batch):
        """
        Evaluate the baseline model on a batch of data.
        
        Parameters:
            batch (torch.Tensor): A tensor containing the batch of data to evaluate.
        Returns:
            base_cost (torch.Tensor): The cost of the tour generated by the baseline model for the given batch of data.
        """
        self.model.eval()  # Set the model to evaluation mode
        with torch.inference_mode():
            # Simulate the model on the batch of instances and generate a tour using the greedy policy
            tour, _ = self.model(batch, self.n_nodes, greedy=True, T=self.T)
            
            # Compute the cost of the tour generated by the baseline model for the given batch of data
            base_cost = pairwise_cost(tour.detach(), batch)
        return base_cost

    def epoch_callback(self, model, epoch):
        """
        Evaluate the new model and compare it with the baseline.
        
        This function is called at each epoch to evaluate whether the new model's performance
        has improved compared to the current baseline. If so, update the baseline.

        Args:
            model (nn.Module): The new candidate model to be evaluated.
            epoch (int): The current epoch number.
        """
        # Evaluate the new model on the dataset and compute its mean cost
        print("Evaluating candidate model on evaluation dataset")

        # Run rollouts for the new model, compute baseline values and mean cost
        candidate_vals = rollout(model, self.dataset, self.n_nodes, self.T)
        
        # Calculate the mean of the new model's performance
        candidate_mean = candidate_vals.mean()

        # Compare with the current baseline
        print(f"Epoch {epoch} candidate mean {candidate_mean}, baseline epoch {self.epoch} mean {self.mean}, difference {candidate_mean - self.mean}")

        if candidate_mean < self.mean:
            # Perform a paired t-test to check if the new model is significantly better
            t, p = ttest_rel(candidate_vals, self.bl_vals)
            p_val = p / 2  # One-sided t-test
            assert t < 0, "T-statistic should be negative"

            # Print the results of the t-test
            print(f"p-value: {p_val}")
            
            if p_val < 0.05:
                # Update the baseline if the new model is better
                print("Update baseline")
                self._update_model(model, epoch)
    def state_dict(self):
        """
        Returns a dictionary containing the current state of the RolloutBaseline object.

        This includes the copied model, the dataset used for rollouts, and the current epoch number.
        """
        return {
            'model': self.model,
            'dataset': self.dataset,
            'epoch': self.epoch
        }

    def load_state_dict(self, state_dict):
        """Load the baseline state from a saved checkpoint"""
        # Load the model from the checkpointed state dictionary
        loaded_model = copy.deepcopy(self.model)
        loaded_model.load_state_dict(state_dict['model'].state_dict())

        # Update the baseline with the loaded model's values
        self._update_model(loaded_model, state_dict['epoch'])
